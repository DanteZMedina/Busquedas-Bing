methods 
then & catch 

then:  returns a promise. it takes up to two arguments: callback functions for the success and failure cases of the promise. 
Parameters: 
onFulfilled (Optional) - A Function called if the Promise is fulfilled. This function has one argument, the fulfillment value. If it is not a function, it is internally replaced with an identity function ((x) => x) which simply passes the fulfillment value forward.

onRejected (Optional) - A Function called if the Promise is rejected. This function has one argument, the rejection reason. If it is not a function, it is internally replaced with a thrower function ((x) => { throw x; }) which throws the rejection reason it received.


catch()
Returns a promise and deals with rejected cases only. It behaves the same as calling promise.prototype.then(undefined, onRejected) 

// Example: A promise that will be rejected or resolved depending on a parameter
function myPromise(param) {
  return new Promise((resolve, reject) => {
    if (param) {
      resolve("Promise resolved");
    } else {
      reject("Promise rejected");
    }
  });
}
myPromise(true)
  .then((data) => {
    console.log(data);
  })
// Output: Promise resolved

myPromise(false)
  .catch((data) => {
    console.log(data);
  })
// Output: Promise rejected


finally()


method of a Promise schedules a function, the callback function, to be called when the promise is settled. Like then() and catch(), it immediately returns an equivalent Promise object, allowing you to chain calls to another promise method, an operation called composition.

Parameters:

onFinally  - A Function called when the Promise is settled. This handler receives no parameters.


function myPromise() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Promise resolved");
    }, 2000);
  });
}
myPromise()
  .then((data) => {
    console.log(data);
  })
  .finally(() => {
    console.log("Promise is done");
  })
// Output: Promise resolved
// Output: Promise is done


Promises chaining



Promise chaining allows us to perform a series of asynchronous operations in a sequence, where each operation starts once the previous one has completed. This allows us to avoid the nested structure of callbacks (callback hell) and instead write code that is more modular and easier to read.

Here's an example with two promises:

// A function that returns a promise which resolves after 2 seconds
function firstAsyncOperation() {
  return new Promise((resolve, reject) => {
      setTimeout(() => {
          console.log('First operation completed');
          resolve(10); // Resolve the promise with some value
      }, 2000);
  });
}

// A function that returns a promise which resolves after 1 second
function secondAsyncOperation(number) {
  return new Promise((resolve, reject) => {
      setTimeout(() => {
          console.log('Second operation completed');
          resolve(number * 2); // Resolve with the result of some computation
      }, 1000);
  });
}

// Chaining the two promises
firstAsyncOperation() // Call the first function which returns a promise
  .then(result => {
      // Once the first promise resolves, the result can be used in the next promise
      return secondAsyncOperation(result);
  })
  .then(finalResult => {
      // Handle the final result of the second promise
      console.log('Final result:', finalResult);
  })
  .catch(error => {
      // If any promise in the chain rejects, this catch block will handle the error
      console.error('An error occurred:', error);
  });
  